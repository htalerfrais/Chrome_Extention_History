---
alwaysApply: true
---
# Current Architecture - Chrome Extension History Project

> **âš ï¸ IMPORTANT**: This document must be updated whenever the architecture is modified, components are added/removed, or significant structural changes are made to the project.

## Overview

This is a **Chrome Extension + React Frontend + Backend API + PostgreSQL Database** system that analyzes browsing history and organizes it into thematic sessions using AI-powered LLM services. The architecture follows a modern client-server pattern with React UI, extension services bridge, remote AI analysis capabilities, **conversational chat interface** for interactive history exploration, and **persistent database storage** with semantic search capabilities using pgvector extension.

## High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CHROME EXTENSION (Frontend)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Background Service Worker  â”‚  Popup Interface  â”‚  React Dashboardâ”‚
â”‚  - Data Collection          â”‚  - Quick Search   â”‚  - Modern UI    â”‚
â”‚  - Real-time Updates       â”‚  - History Lookup â”‚  - State Mgmt   â”‚
â”‚  - Local Storage           â”‚  - Simple UI      â”‚  - Component Treeâ”‚
â”‚                             â”‚                   â”‚  - ExtensionBridgeâ”‚
â”‚                             â”‚                   â”‚  - Chat Interfaceâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â”‚ ExtensionBridge Pattern
                                â”‚ (React â†” Extension Services)
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EXTENSION SERVICES LAYER                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Session Management  â”‚  API Client       â”‚  Data Processing    â”‚
â”‚  - session_mgmt.js   â”‚  - api_client.js  â”‚  - preprocess.js   â”‚
â”‚  - Time grouping     â”‚  - HTTP comm      â”‚  - URL filtering   â”‚
â”‚  - API formatting    â”‚  - Error handling â”‚  - Feature extract â”‚
â”‚                      â”‚  - Chat messages   â”‚                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â”‚ HTTP API Calls
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BACKEND API (Python FastAPI)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  FastAPI Server  â”‚  Clustering Service  â”‚  LLM Service         â”‚
â”‚  - REST Endpointsâ”‚  - Theme Detection   â”‚  - AI Text Generationâ”‚
â”‚  - Health Checks â”‚  - Pattern Analysis  â”‚  - Multi-Provider   â”‚
â”‚  - CORS Support  â”‚  - Keyword Matching  â”‚  - Provider Abstractionâ”‚
â”‚  - Chat Endpoint â”‚  - Session Clusteringâ”‚  - OpenAI/Anthropic â”‚
â”‚  - Database Integrationâ”‚              â”‚  - Google/Ollama    â”‚
â”‚                  â”‚                      â”‚  - Chat Service     â”‚
â”‚                  â”‚                      â”‚  - Database Service â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â”‚ Data Models & Validation
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATA LAYER (Pydantic + SQLAlchemy Models)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Pydantic Models â”‚  SQLAlchemy Models  â”‚  Database Service     â”‚
â”‚  - HistoryItem   â”‚  - User             â”‚  - CRUD Operations    â”‚
â”‚  - HistorySessionâ”‚  - Session          â”‚  - Context Manager    â”‚
â”‚  - ClusterResult â”‚  - Cluster          â”‚  - Transaction Mgmt   â”‚
â”‚  - ClusteringRespâ”‚  - HistoryItem      â”‚  - Dictionary Returns â”‚
â”‚  - LLM Models    â”‚  - Relationships    â”‚  - Error Handling     â”‚
â”‚  - Chat Models   â”‚  - Vector Support   â”‚  - Session Decoupling â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â”‚ Database Operations
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATABASE LAYER (PostgreSQL + pgvector)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PostgreSQL 15    â”‚  pgvector Extension â”‚  Vector Search       â”‚
â”‚  - Users Table    â”‚  - Vector Columns   â”‚  - Semantic Search   â”‚
â”‚  - Sessions Table â”‚  - Embeddings       â”‚  - Similarity Search â”‚
â”‚  - Clusters Table â”‚  - Indexes          â”‚  - Performance       â”‚
â”‚  - History Items  â”‚  - 1536 Dimensions  â”‚  - Cosine Similarity â”‚
â”‚  - SQLAlchemy ORM â”‚  - Context Manager  â”‚  - CRUD Operations   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Component Responsibilities

### **Frontend (Chrome Extension + React)**

#### **Background Service Worker** (`background.js`)
- **Responsibility**: Continuous data collection and preprocessing
- **Key Functions**:
  - Collects Chrome history data (up to 5000 items)
  - Real-time updates via `chrome.history.onVisited` listener
  - Stores preprocessed data in `chrome.storage.local`
  - Applies URL filtering and deduplication

#### **Popup Interface** (`popup.html`, `popup.js`)
- **Responsibility**: Quick access search interface
- **Key Functions**:
  - Simple search functionality across stored history
  - Displays search results with favicons and metadata
  - Provides access to React dashboard
  - Compact 320px width design

#### **React Dashboard** (`frontend/src/`)
- **Responsibility**: Modern UI with lazy loading, on-demand session analysis, and conversational chat interface
- **Key Functions**:
  - **App Component**: Main state management with lazy loading architecture and 70/30 layout
  - **Session State Management**: Tracks analysis states (pending/loading/completed/error) per session
  - **Header Component**: Logo, title, and action buttons with click handlers
  - **StatusBar Component**: Real-time status updates with loading/success/error states
  - **MainLayout Component**: 70/30 responsive layout (Dashboard 70%, Chat 30%)
  - **Dashboard Component**: Main content area for session and cluster display
  - **SessionTabs Component**: Interactive session navigation with analysis state indicators
  - **ChatWindow Component**: Conversational interface with message history and input
  - **ChatBubble Component**: Individual message display with user/assistant styling
  - **LoadingSpinner & ErrorDisplay**: User feedback components
  - **ExtensionBridge Service**: Clean interface to extension services including chat

#### **Extension Services Bridge** (`frontend/src/services/extensionBridge.ts`)
- **Responsibility**: Connect React UI to existing extension services including chat functionality
- **Key Functions**:
  - Access Chrome storage and APIs
  - Use existing SessionManager for data processing
  - `clusterSession()` method for single session backend communication
  - `sendChatMessage()` method for conversational chat communication
  - Provide type-safe interface for React components
  - Handle service initialization and error recovery

#### **Data Processing Layer** (`extension/utils/`)
- **Session Manager** (`session_management.js`):
  - Groups history items into time-based sessions (120min gap)
  - Formats data for API consumption
  - Handles session statistics and validation
- **History Preprocessor** (`preprocess_history.js`):
  - URL normalization and cleaning
  - Duplicate detection and removal
  - Feature extraction (hostname, path, search queries)
  - Date formatting and enrichment

#### **API Client** (`extension/api/`)
- **API Client** (`api_client.js`):
  - Handles HTTP communication with backend
  - `clusterSession()` method for single session processing
  - `sendChatMessage()` method for conversational chat
  - Implements retry logic and error handling
  - Manages request timeouts and failures
- **Configuration** (`config.js`):
  - Environment management (dev/production)
  - API endpoint configuration including `/chat` endpoint
  - Request settings and timeouts

### **Backend (Python FastAPI)**

#### **API Server** (`main.py`)
- **Responsibility**: RESTful API endpoints and request handling
- **Key Functions**:
  - Health check endpoints (`/`, `/health`)
  - Single session clustering endpoint (`/cluster-session`)
  - Chat conversation endpoint (`/chat`)
  - CORS configuration for Chrome extension
  - Service initialization and dependency injection
  - Error handling and logging
  - **Note**: No direct database repository in API layer - all database operations go through business logic services

#### **Clustering Service** (`clustering_service.py`)
- **Responsibility**: LLM-driven thematic clustering for single session analysis
- **Key Functions**:
  - **Single session processing**: `cluster_session()` method processes one session at a time
  - **LLM-powered cluster identification**: Uses AI to propose 1-10 thematic clusters per session
  - **Detailed summaries**: Generates 2-3 sentence summaries describing activities, websites, and user goals
  - **Generic cluster enforcement**: Always includes a generic cluster for miscellaneous items
  - **Intelligent item assignment**: Batched LLM calls (10 items per batch) to assign items to identified clusters
  - **On-demand analysis**: Enables lazy loading and faster initial response times
  - **Robust error handling**: Fallback mechanisms for LLM failures
  - **JSON extraction**: Parses LLM responses with error recovery
  - **Batch optimization**: Groups items for efficient LLM API usage

#### **LLM Service** (`llm_service.py`)
- **Responsibility**: AI-powered text generation and analysis
- **Key Functions**:
  - Multi-provider LLM abstraction
  - Provider management and routing
  - Request validation and error handling
  - Usage tracking and metadata extraction

#### **Chat Service** (`chat_service.py`)
- **Responsibility**: Conversational chat interface for interactive history exploration
- **Key Functions**:
  - **Stateless conversation management**: Client-side history storage
  - **Prompt building**: System prompts with conversation context
  - **LLM integration**: Uses existing LLMService for text generation
  - **Conversation ID management**: Unique identifiers for chat sessions
  - **Error handling**: Graceful fallbacks for LLM failures

#### **User Service** (`user_service.py`)
- **Responsibility**: Business logic for user operations and orchestration
- **Key Functions**:
  - **User CRUD operations**: Create, read, update, delete users
  - **User validation**: Email format and data validation
  - **Repository integration**: Uses DatabaseRepository for data operations
  - **Business logic**: User existence checks, get-or-create patterns
  - **Pagination support**: List users with limit/offset
  - **Note**: Currently contains method stubs - implementation pending

#### **LLM Providers** (`providers/`)
- **Provider Interface** (`base_provider.py`):
  - Abstract base class for all LLM providers
  - Standardized interface for text generation
  - Request validation and model management
- **OpenAI Provider** (`openai_provider.py`):
  - GPT models integration (default: GPT-4.1 Mini)
  - OpenAI API communication
  - Token usage tracking
- **Anthropic Provider** (`anthropic_provider.py`):
  - Claude models integration (default: Claude-3 Sonnet)
  - Anthropic API communication
  - Usage metadata extraction
- **Google Provider** (`google_provider.py`):
  - Gemini models integration (default: Gemini-2.5 Pro)
  - Google Generative AI API
  - Response parsing and metadata
  - Token consumption logging
- **Ollama Provider** (`ollama_provider.py`):
  - Local LLM models (Llama2, etc.)
  - Local API communication
  - Offline text generation capability

#### **Data Models** (`models/`)
- **Pydantic Models** (API validation and serialization):
  - **Session Models** (`session_models.py`):
    - `HistoryItem`: Individual browsing entry with URL features
    - `HistorySession`: Time-grouped browsing session
    - `ClusterResult`: Thematic grouping result
    - `SessionClusteringResponse`: API response format
  - **LLM Models** (`llm_models.py`):
    - `LLMRequest`: Text generation request with provider settings
    - `LLMResponse`: Generated text with metadata and usage info
    - Provider-agnostic request/response handling
  - **Chat Models** (`chat_models.py`):
    - `ChatMessage`: Individual chat message with role and timestamp
    - `ChatRequest`: Chat request with message, history, and provider
    - `ChatResponse`: Chat response with generated text and metadata
    - `MessageRole`: User, Assistant, System role enumeration
    - `ChatProvider`: LLM provider selection enumeration
- **SQLAlchemy Models** (`database_models.py`):
  - `User`: User model with email, username, and relationships
  - `Session`: Browsing session with timestamps and vector embeddings
  - `Cluster`: Thematic cluster with name, description, and embeddings
  - `HistoryItem`: Individual history item with URL, title, and metadata
  - Relationships: User â†’ Sessions â†’ Clusters â†’ HistoryItems
  - Vector support: 1536-dimensional embeddings for semantic search
  - Automatic timestamps and cascade delete operations

#### **Database Layer** (`database.py`, `repositories/`)
- **Database Configuration** (`database.py`):
  - **Engine**: Connection pool to PostgreSQL with pgvector support
  - **SessionLocal**: Factory for creating database sessions
  - **Health Check**: `check_db_connection()` for connection validation
  - **Connection Pool**: Pre-ping enabled for reliability
- **Repository Pattern** (`repositories/database_repository.py`):
  - **Context Manager**: `_get_session()` for automatic session lifecycle
  - **CRUD Operations**: Create, read, update, delete for all models
  - **Transaction Management**: Automatic commit/rollback with error handling
  - **Dictionary Returns**: Converts SQLAlchemy objects to dicts for decoupling
  - **Error Handling**: Robust error logging and graceful failure recovery
  - **Session Decoupling**: Avoids SQLAlchemy session dependencies in returned data
  - **Generic Operations**: `_execute()` wrapper for consistent error handling

## React Frontend Architecture

### **Component Tree**
```
App (State Management + ExtensionBridge + Auto-initialization)
â”œâ”€â”€ Header (Logo + Navigation + Settings)
â”œâ”€â”€ StatusBar (Loading/Success/Error States)
â”œâ”€â”€ MainLayout (70/30 Responsive Layout)
â”‚   â”œâ”€â”€ Main Content (70%)
â”‚   â”‚   â”œâ”€â”€ LoadingSpinner (Conditional Rendering)
â”‚   â”‚   â”œâ”€â”€ ErrorDisplay (Error Handling + Retry)
â”‚   â”‚   â””â”€â”€ Dashboard (Session Analysis)
â”‚   â”‚       â””â”€â”€ ClustersSection (Cluster Display)
â”‚   â”‚           â”œâ”€â”€ SessionInfo (Session Metadata)
â”‚   â”‚           â””â”€â”€ ClusterGrid
â”‚   â”‚               â””â”€â”€ ClusterCard[] (Individual Clusters)
â”‚   â”‚                   â””â”€â”€ ClusterItem[] (History Items)
â”‚   â””â”€â”€ Chat Sidebar (30%)
â”‚       â””â”€â”€ ChatWindow (Conversational Interface)
â”‚           â”œâ”€â”€ ChatHeader (Title + Status)
â”‚           â”œâ”€â”€ ChatMessages (Scrollable Message List)
â”‚           â”‚   â””â”€â”€ ChatBubble[] (Individual Messages)
â”‚           â””â”€â”€ ChatInput (Message Input + Send Button)
```

### **State Management**
- **React Hooks**: useState, useEffect for local component state
- **Lazy Loading State**: `availableSessions`, `sessionAnalysisStates` for on-demand processing
- **Auto-initialization**: Automatic service loading and first session analysis on app start
- **Session Navigation**: `currentSessionIndex`, `activeSessionId` for session management
- **Chat State**: `messages`, `conversationId`, `isLoading`, `error` for conversational interface
- **Props Flow**: Top-down data flow with callback props for user actions
- **ExtensionBridge**: Service layer for Chrome extension integration including chat
- **Type Safety**: Centralized TypeScript interfaces in `types/` directory
- **Error Handling**: Comprehensive error states with retry mechanisms

### **Build Process**
- **Development**: Vite dev server at `http://localhost:5173`
- **Production**: Vite builds to `extension/dashboard-assets/`
- **Chrome Extension**: Loads React bundle from `dashboard-assets/index.js`
- **CSS**: Bundled into `dashboard-assets/assets/index.css`

## LLM Clustering Workflow

The clustering service now operates through a sophisticated two-phase LLM-driven process:

### **Phase 1: Cluster Identification**
1. **Session Analysis**: Each session is processed independently
2. **LLM Prompting**: Simplified item data (title, hostname, path, search query) sent to LLM
3. **Cluster Proposal**: LLM returns 1-10 thematic clusters with IDs, themes, and detailed summaries
4. **Schema Validation**: Response parsed and cleaned with automatic generic cluster addition if missing

### **Phase 2: Item Assignment**
1. **Batch Processing**: Items grouped into batches of 10 for efficiency (reduced due to Gemini token management)
2. **LLM Assignment**: Each batch assigned to identified clusters via LLM
3. **Error Recovery**: Fallback mechanisms ensure all items are assigned
4. **Result Assembly**: ClusterResult objects created with assigned items

### **Key Features**
- **Provider Flexibility**: Uses Google Gemini 2.5 Pro by default, configurable to other providers
- **Robust Parsing**: JSON extraction with error recovery from malformed LLM responses
- **Performance Optimization**: Batched processing (10 items per batch) reduces API calls and costs
- **Graceful Degradation**: Fallback clusters ensure system reliability
- **Generic Cluster Guarantee**: Always includes a generic cluster for items that don't fit specific themes

## Data Flow

### **Initial Load (Auto-initialization)**
1. **Data Collection**: Chrome history â†’ Background worker â†’ Local storage
2. **React Initialization**: Dashboard loads â†’ ExtensionBridge waits for services
3. **Auto-load**: Services ready â†’ Automatically load sessions and analyze most recent
4. **Service Layer**: ExtensionBridge â†’ SessionManager â†’ Local processing
5. **UI Update**: Session tabs display with auto-analysis of first session

### **On-Demand Analysis (Per Session)**
1. **User Action**: Click session tab â†’ Triggers `analyzeSession(sessionId)`
2. **Service Layer**: ExtensionBridge â†’ ApiClient â†’ Backend `/cluster-session`
3. **LLM Processing**: Backend receives single session â†’ LLM cluster identification â†’ Batched item assignment
4. **AI Enhancement**: LLM service generates thematic clusters and assigns items intelligently
5. **React Update**: Backend returns single session result â†’ React state updates â†’ UI re-renders
6. **Note**: Database storage integration pending - currently results are not persisted

### **Chat Conversation Flow**
1. **User Input**: Type message in ChatWindow â†’ Triggers `handleSendMessage()`
2. **Optimistic UI**: User message immediately displayed in chat
3. **Service Layer**: ExtensionBridge â†’ ApiClient â†’ Backend `/chat`
4. **Chat Processing**: Backend receives message + history â†’ ChatService builds prompt â†’ LLM generates response
5. **Response Display**: Assistant message added to chat â†’ Auto-scroll to latest message
6. **Stateless Design**: Conversation history managed client-side for scalability

## Key Design Patterns

### **Architecture Patterns**
- **Extension Services Bridge Pattern**: Clean separation between React UI and Chrome extension services
- **Repository Pattern**: DatabaseRepository provides centralized database operations with clean interface
- **Service Layer Pattern**: Business logic services orchestrate repository operations
- **Provider Abstraction Pattern**: Unified interface for multiple LLM providers
- **API Gateway Pattern**: Centralized backend service for complex processing

### **Data Processing Patterns**
- **Service Worker Pattern**: Background processing for continuous data collection
- **Session-based Processing**: Groups related browsing activities by time
- **LLM-driven Clustering**: AI-powered thematic analysis and intelligent categorization
- **Batch Processing Pattern**: Efficient LLM API usage through item batching (20 items per batch)
- **Fallback Strategy Pattern**: Robust error handling with graceful degradation

### **Frontend Patterns**
- **Lazy Loading Pattern**: On-demand session analysis for improved performance
- **Auto-initialization Pattern**: Automatic service loading and first session analysis
- **Optimistic UI Pattern**: Immediate user feedback with rollback on errors
- **Component Composition**: React components with clear responsibilities
- **Props Down, Events Up**: Unidirectional data flow with callback props

### **Communication Patterns**
- **Stateless Chat Pattern**: Client-managed conversation history for scalability
- **Context Manager Pattern**: `_get_session()` for automatic session lifecycle management
- **Dictionary Conversion Pattern**: SQLAlchemy objects converted to dicts for session decoupling
- **Transaction Pattern**: Automatic commit/rollback with error handling

### **Code Organization Patterns**
- **Separation of Concerns**: Extension handles data/APIs, React handles UI/UX
- **Single Responsibility Principle**: Each session analyzed independently
- **Centralized Type Management**: DRY principle with shared TypeScript interfaces
- **Model Separation**: Pydantic for API validation, SQLAlchemy for database mapping

## Technology Stack

### Frontend
- **React 19**: Modern UI library with hooks and functional components
- **TypeScript**: Type safety and better developer experience
- **Vite**: Fast build tool and development server
- **Chrome Extension API**: History, Storage, Tabs permissions
- **ExtensionBridge Pattern**: Service layer for Chrome API access
- **CSS**: Component-based styling with build-time bundling

### Backend
- **FastAPI**: Modern Python web framework
- **Pydantic**: Data validation and serialization
- **SQLAlchemy**: Python ORM for database operations
- **pgvector**: PostgreSQL extension for vector similarity search
- **httpx**: Async HTTP client for LLM API calls
- **Docker**: Containerized deployment
- **Uvicorn**: ASGI server
- **Repository Pattern**: Clean database abstraction layer

### Database
- **PostgreSQL 15**: Robust relational database
- **pgvector**: Vector similarity search extension
- **SQLAlchemy ORM**: Database models and relationships
- **Context Manager**: Session lifecycle management
- **Dictionary Conversion**: Session decoupling for data transfer

### LLM Integration
- **OpenAI API**: GPT models for text generation
- **Anthropic API**: Claude models for advanced reasoning
- **Google Generative AI**: Gemini models for multimodal capabilities
- **Ollama**: Local LLM models for offline processing

## Configuration

### **Application Settings** (`config.py`)
- **Session Gap**: 120 minutes between sessions
- **History Limit**: 5000 items maximum
- **API Timeout**: 30 seconds for main requests, 60 seconds for Ollama
- **Retry Logic**: 3 attempts with exponential backoff
- **LLM Clustering**: AI-powered thematic analysis with Google Gemini 2.0 Flash (primary provider)
- **Chat Provider**: Configurable LLM provider (OpenAI/Anthropic/Google/Ollama)
- **Batch Size**: 20 items per LLM assignment call (optimized for Gemini token management)
- **Chat History**: Client-side conversation management (stateless backend)
- **Layout**: 70/30 responsive split (Dashboard/Chat)
- **Vector Dimensions**: 1536 (OpenAI embedding model standard)

### **Environment Configuration**
- **Development**: Uses `.env` file when not in Docker container
- **Production**: Environment variables passed directly via Docker Compose
- **API Keys**: Secure environment-based configuration for all LLM providers
- **Database URL**: PostgreSQL connection string with pgvector support
- **CORS**: Configured for Chrome extension and localhost development

### **Build Configuration**
- **React Build**: Outputs to extension/dashboard-assets/ for Chrome extension compatibility
- **Database**: PostgreSQL 15 with pgvector extension for semantic search
- **Docker**: Containerized backend with persistent database volumes

## Environment Variables

### **LLM Provider Keys**
- `OPENAI_API_KEY`: OpenAI API access key
- `ANTHROPIC_API_KEY`: Anthropic API access key
- `GOOGLE_API_KEY`: Google Generative AI API key

### **Database Configuration**
- `DATABASE_URL`: PostgreSQL connection string with pgvector support
- `POSTGRES_USER`: PostgreSQL username (default: postgres)
- `POSTGRES_PASSWORD`: PostgreSQL password (default: postgres)

### **Service Configuration**
- `OLLAMA_BASE_URL`: Custom Ollama server URL (default: localhost:11434)
- `DOCKER_CONTAINER`: Flag to indicate Docker environment (affects .env loading)

## Deployment

### **Development Environment**
- **Extension**: Load unpacked from `extension/` folder in Chrome
- **Backend**: Docker container on localhost:8000 via `.\scripts\dev_up.ps1`
- **Database**: PostgreSQL container with persistent volumes
- **React Frontend**: Vite dev server at `http://localhost:5173`
- **LLM Services**: External API dependencies (OpenAI, Anthropic, Google)

### **Production Environment**
- **Extension**: Chrome Web Store (future) / Developer mode (current)
- **Backend**: Docker container on cloud infrastructure
- **Database**: PostgreSQL with pgvector extension
- **React Frontend**: Built into extension/dashboard-assets/ via Vite
- **Build Process**: `cd frontend && npm run build` (builds to extension/)

## Development Workflow

1. **Backend**: `.\scripts\dev_up.ps1` (Docker)
2. **Frontend**: `cd frontend && npm run dev` (Vite dev server)
3. **Extension**: Load unpacked from `extension/` folder
4. **Production**: `cd frontend && npm run build` (builds to extension/)

---

**Last Updated**: January 2025
**Version**: 0.9.0
**Status**: Database Layer Complete + Repository Pattern Implemented ğŸ—„ï¸

### **Current Implementation Status**
- âœ… **Database Layer**: PostgreSQL + pgvector + Repository pattern fully implemented
- âœ… **Backend Services**: ClusteringService, ChatService, LLMService, UserService (stubs)
- âœ… **Frontend**: React dashboard with auto-initialization and lazy loading
- âœ… **Extension Bridge**: Complete service layer for Chrome extension integration
- âš ï¸ **Database Integration**: Repository pattern ready, but clustering results not yet persisted
- âš ï¸ **User Service**: Method stubs implemented, business logic pending
- ğŸ”„ **Next Phase**: Database persistence integration for clustering results
