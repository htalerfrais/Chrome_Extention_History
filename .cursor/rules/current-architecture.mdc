---
alwaysApply: true
---
# Current Architecture - Chrome Extension History Project

## Overview
A Chrome Extension + React dashboard + FastAPI backend + PostgreSQL system that analyzes browsing history into thematic sessions using LLMs. Results are persisted; repeated analyses return cached results.

## High-Level Diagram
```
Chrome Extension (UI + BG) ── Extension Services ──► FastAPI ──► PostgreSQL
         ▲                         │                   │
         │                         ▼                   │
      React UI  ◄── ExtensionBridge / ApiClient ──► Services  ──► ORM
```

## Components

### Chrome Extension
- Background worker (`extension/background.js`)
  - Collects and preprocesses history; stores in `chrome.storage.local`
  - Authenticates with Google (`chrome.identity`) and stores `userToken`
  - Preprocessing pipeline: `datesFormating` → `addUrlFeatures` → `filterHistoryURL`
    - URL similarity threshold configurable via `ExtensionConstants.URL_SIMILARITY_THRESHOLD` (default 0.8)
- React dashboard (`extension/dashboard.html` + `dashboard-assets/`)
  - Session exploration, on-demand analysis, chat sidebar
- Services
  - Session manager (`extension/utils/session_management.js`): groups items; deterministic `session_identifier` (stable for current sessions using `startTime + firstUrl`) and API formatting
  - API client (`extension/api/api_client.js`): injects `user_token` from storage; calls `/cluster-session`, `/chat`, `/authenticate` (supports `?force=true` for reanalysis)
  - ExtensionBridge (`frontend/src/services/extensionBridge.ts`): facade for React to use extension services

### Backend (FastAPI)
- API (`backend/app/main.py`)
  - Endpoints: `/`, `/health`, `/authenticate`, `/cluster-session`
  - `/cluster-session`: validate `user_token` → get/create user → decide `force` (explicit query param or current-session heuristic via `settings.current_session_gap_minutes`, default 30) → cluster or return cached result
- Services (`backend/app/services/`)
  - ClusteringService: LLM identifies thematic clusters → items assigned via embedding cosine similarity (threshold in `settings.clustering_similarity_threshold`); hardcoded generic cluster for unmatched items; canonicalizes `session_identifier` to `u{user_id}:{client_id}`, cache check (skipped if `force=True`) + persistence via MappingService
  - MappingService: Pydantic ↔ ORM conversion; persists and reconstructs Session → Clusters → HistoryItems
  - LLMService + Providers: provider-agnostic text generation (OpenAI/Anthropic/Google/Ollama)
  - ChatService: conversational LLM with tool calling via `[SEARCH: query | filter:value]` tag detection (1 LLM call simple, 2 calls when search needed)
  - SearchService: two-stage semantic search with filters (`date_from`, `date_to`, `title_contains`, `domain_contains`); wildcard `*` skips embedding, relies on filters only
  - UserService: get-or-create user by token
- Repository (`backend/app/repositories/database_repository.py`)
  - Sessions: `create_session`, `get_session_by_identifier`, `get_session_with_relations`, `delete_session_by_identifier`
  - Clusters: `create_cluster`, `get_clusters_by_session_id`, `search_clusters_by_embedding` (cosine distance + optional date filters on session)
  - HistoryItems: `create_history_item`, `get_history_items_by_cluster_id`, `search_history_items_by_embedding` (optional cluster filter)
  - `_execute` wrapper returns dict/list/primitives and manages session lifecycle/commit/rollback

### Data Layer
- Pydantic (`backend/app/models/`)
  - `HistorySession`: user_token, session_identifier, start/end, items
  - `SessionClusteringResponse`: session_identifier, times, clusters
  - `ClusterResult`: ephemeral `cluster_id` used only during LLM assignment
  - `HistoryItem`: API representation
- SQLAlchemy (`backend/app/models/database_models.py`)
  - `User(id, token)`
  - `Session(id, user_id, session_identifier [unique], start_time, end_time)`
  - `Cluster(id, session_id, name, description, embedding VECTOR(768))`
  - `HistoryItem(id, cluster_id, url, title, domain, visit_time, raw_semantics, embedding VECTOR(768))`

### Database
- PostgreSQL + SQLAlchemy ORM; pgvector columns (768 dims) on clusters and history items for semantic search
- `sessions.session_identifier` unique for idempotent persistence and cache hits

## Critical Flows

### Authentication
1. Extension obtains Google token via `chrome.identity.getAuthToken`
2. Sends token to `/authenticate` (stored as `User.token`)
3. Token stored as `userToken` in `chrome.storage.local`

### Analyze One Session
1. Extension builds session with deterministic `session_identifier` + `user_token`
2. Backend: get/create user → decide `force` (explicit or heuristic)
3. If `force=True`: delete existing session (cascade) and re-create with same canonical id; else check cache via MappingService
4. If cached and not forced: return DB result; otherwise run LLM clustering → persist via MappingService → return

### Deterministic IDs
- Client `session_identifier` computed in `SessionManager` (stable for current sessions using `startTime + firstUrl`)
- Server canonicalizes to `u{user_id}:{client_session_identifier}` to avoid cross-user collisions and ensure idempotency

## Design Principles
- Separation of concerns (UI / extension services / API / persistence)
- Repository pattern for DB access, mapping service for conversions
- Idempotent session processing via unique session_identifier
- Provider abstraction for LLMs; stateless chat

## Dev Quickstart
- Backend: `./scripts/dev_up.ps1`
- Frontend build: `cd frontend && npm run build`
- Load extension: Chrome → `chrome://extensions/` → Load unpacked → `extension/`
- Health: `http://localhost:8000/health`

Last Updated: December 2025 (ClusteringService embedding-based assignment)

